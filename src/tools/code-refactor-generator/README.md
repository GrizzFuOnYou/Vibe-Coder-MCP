# Code Refactor Generator Tool (`refactor-code`)

## Overview

This tool takes an existing code snippet and refactoring instructions, then uses an LLM to generate the improved code. It can optionally use the content of the surrounding file as context to perform more accurate refactoring.

## Inputs

| Parameter               | Type     | Description                                                                                                                               | Required |
| :---------------------- | :------- | :---------------------------------------------------------------------------------------------------------------------------------------- | :------- |
| `language`              | `string` | The programming language of the code snippet (e.g., 'typescript', 'python', 'javascript').                                                | Yes      |
| `codeContent`           | `string` | The actual code snippet to be refactored.                                                                                                 | Yes      |
| `refactoringInstructions` | `string` | Specific instructions on how the code should be refactored (e.g., 'extract loop', 'improve variable names', 'add error handling', 'use async/await'). | Yes      |
| `contextFilePath`       | `string` | Optional. Relative path to a file whose content provides broader context for the refactoring task.                                        | No       |

## Outputs

*   **Primary Output:** The refactored code snippet as a string within the `CallToolResult.content` array (type `text`).
*   **File Storage:** This tool does not save any files to the `workflow-agent-files` directory. The refactored code is returned directly in the MCP response.

## Asynchronous Execution

This tool executes asynchronously due to the potential time required for LLM processing.
1.  When you call this tool, it will immediately return a **Job ID**.
2.  The refactoring process runs in the background.
3.  Use the `get-job-result` tool with the received Job ID to retrieve the final refactored code once the job is complete.

## Workflow

```mermaid
flowchart TD
    A[Start refactor-code] --> B{Validate Input Schema};
    B --> |Invalid| Z[Return Error];
    B --> |Valid| C{Context File Path Provided?};
    C --> |Yes| D[Read Context File Content];
    D --> E[Build LLM Prompt];
    C --> |No| E;
    E --> F[Call LLM (e.g., Gemini) via OpenRouter];
    F --> G{LLM Call Successful?};
    G --> |No| Z;
    G --> |Yes| H[Extract Refactored Code from LLM Response];
    H --> I[Format Code (e.g., trim whitespace, remove markdown)];
    I --> J[Return Success with Refactored Code String];
    J --> X[End];
    Z --> X;
```

1.  **Validate Input:** The incoming parameters are validated against the `codeRefactorInputSchema`. If validation fails, an error is returned.
2.  **Read Context (Optional):** If `contextFilePath` is provided, the tool attempts to read the content of the specified file using the `fileReader` utility.
3.  **Build Prompt:** A detailed prompt is constructed for the LLM, including:
    *   The original `codeContent`.
    *   The specific `refactoringInstructions`.
    *   The `language` of the code.
    *   The content read from `contextFilePath` (if provided), indicating it's context for the snippet.
    *   Instructions asking the LLM to return *only* the refactored code based on the instructions.
4.  **Call LLM:** The constructed prompt is sent to the configured LLM (e.g., Gemini via OpenRouter).
5.  **Process Response:** The refactored code generated by the LLM is extracted from the response. Formatting (like trimming whitespace and removing potential markdown code fences) is applied.
6.  **Return Result:** A successful `CallToolResult` containing the refactored code string is returned.

## Usage Example

```json
{
  "tool_name": "refactor-code",
  "arguments": {
    "language": "javascript",
    "codeContent": "function process(data) { var result = []; for(var i=0; i<data.length; i++) { if(data[i].value > 10) result.push(data[i].id); } return result; }",
    "refactoringInstructions": "Use modern JavaScript (ES6+). Use filter and map instead of a for loop. Use const/let instead of var."
  }
}
```

Invoked via AI Assistant:
`"Refactor this JS code to use filter/map and const/let: function process(data) { var result = []; for(var i=0; i<data.length; i++) { if(data[i].value > 10) result.push(data[i].id); } return result; }"`

## System Prompt (Conceptual Excerpt)

```text
You are an expert code refactoring assistant. Refactor the following code snippet based *only* on the provided instructions. Return ONLY the refactored code, without any explanations, comments (unless the refactoring requires them), or markdown formatting.

Language: {{language}}

Refactoring Instructions: {{refactoringInstructions}}

Original Code Snippet:
```{{language}}
{{codeContent}}
```

{{#if contextFileContent}}
Additional Context from file {{contextFilePath}}:
---
{{contextFileContent}}
---
{{/if}}

Refactored Code:
```

## Error Handling

*   **Input Validation Errors:** Returns an error if required inputs are missing or invalid according to the schema.
*   **File Read Errors:** Returns an error if `contextFilePath` is provided but the file cannot be read.
*   **LLM API Errors:** Returns an error if the call to the OpenRouter API fails.
*   **LLM Response Parsing Errors:** Returns an error if the LLM response is malformed or the refactored code cannot be extracted.
